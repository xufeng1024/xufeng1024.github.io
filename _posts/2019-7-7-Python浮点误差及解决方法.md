---
layout:     post   				    # 使用的布局（不需要改）
title:      Python浮点误差与解决方法 				# 标题 
subtitle:   Python浮点误差与解决方法 #副标题
date:       2019-07-07 				# 时间
author:     XF 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Python
	- 知识点
---

## 1.例子

先放上几个程序的例子 

```python
# 浮点数
print("0.1 + 0.1 = ", 0.1 + 0.1)
print("0.1 - 0.1 = ", 0.1 - 0.1)
print("0.1 * 0.1 = ", 0.1 * 0.1)  #计算机无法精确存储0.01，存储了它的近似值。
print("0.1 / 0.1 = ", 0.1 / 0.1)
print("0.3 == 3 * 0.1\t", 0.3 == 3 * 0.1)

a = 0.2
b = 0.1
print("a + b = ", a + b)  #计算机无法精确存储0.3，存储了它的近似值。

#对大多数实数，计算机都无法精确存储。这造成误差。

## #在用计算机解决实际问题时，要考虑上述误差的积累。
```

运行程序，会出现以下结果

```python
0.1 + 0.1 = 0.2 
0.1 - 0.1 = 0.0 
0.1 * 0.1 = 0.010000000000000002 
0.1 / 0.1 = 1.0 
0.3 == 3 * 0.1	 False
a + b = 0.30000000000000004
```

可以看出第3、5、6行的异常之处，接下来就来解释一下。

## 2.浮点数的误差

在计算机中，存储数据使用的是二进制数。先看一下[十进制小数转换位二进制小数](https://www.cnblogs.com/xkfz007/articles/2590472.html)的过程。

比如要存储十进制的小数0.1，转换成二进制小数是无限的

```python
0.0001100110011001100110011001100110011001100110011...
```

在python中，浮点数有53位可用精度，因此十进制的0.1在内部存储中储存的值是二进制小数的近似替代值

```python
0.00011001100110011001100110011001100110011001100110011010
```

它接近但不完全的等于0.1。

计算机取出储存，进行显示时，使用的是舍入值。

需要注意的是，这是二进制浮点的本质：这不是Python中的错误，也不是代码中的错误。您将在支持硬件浮点运算的所有语言中看到相同的类型（尽管某些语言默认情况下可能无法*显示*差异，或者在所有输出模式下）。

其他惊喜也来自这一点。例如，如果您尝试将值2.675舍入到两个小数位，则可以得到此值

```python
>>> round(2.675, 2)
2.67
```

round()函数的作用是四舍五入。2.675保留两位小数的四舍五入约值应该是2.68.但实际输出却是2.67。

实际上2.675被二进制近似替代，它存储在内部的值为

```python
2.67499999999999982236431605997495353221893310546875
```

这个存储的值四舍五入为2.67，这就是错误的根源。

**查看存储在内部的值**，可以使用**decimal**模块。该[`decimal`](https://docs.python.org/2/library/decimal.html#module-decimal)模块还提供了一种很好的方法来“查看”存储在任何特定Python float中的确切值。

```python
>>> from decimal import Decimal
>>> Decimal(2.675)
Decimal('2.67499999999999982236431605997495353221893310546875')
```

这就说明了，刚开始给出的程序中的异常之处。

对多数实数，计算机都无法精确存储。这造成误差。在用计算机解决实际问题时，要考虑上述误差的积累。

## 3.浮点误差的解决方法

python中的decimal模块可以解决上面的烦恼 
decimal模块中，可以通过整数，字符串或原则构建decimal.Decimal对象。如果是浮点数，特别注意因为浮点数本身存在误差，需要先将浮点数转化为字符串。

```python
>>> from decimal import Decimal
>>> from decimal import getcontext
>>> Decimal('4.20') + Decimal('2.10')
Decimal('6.30')
>>> from decimal import Decimal
>>> from decimal import getcontext
>>> x = 4.20
>>> y = 2.10
>>> z = Decimal(str(x)) + Decimal(str(y))
>>> z
Decimal('6.3')
>>> getcontext().prec = 4 #设置精度
>>> Decimal('1.00') /Decimal('3.0')
Decimal('0.3333')
```

当然精度提升的同时，肯定带来的是性能的损失。在对数据要求特别精确的场合（例如财务结算），这些性能的损失是值得的。但是如果是大规模的科学计算，就需要考虑运行效率了。毕竟原生的float比Decimal对象肯定是要快很多的。

## 4.小结

1. Python语言用整数类型来表示数学上的整数，用浮点数类型表示数学上的实数（整数除外）。
2. 计算机会把你心里想的十进制小数转换为二进制小数，然后在内存中存储二进制小数。
3. 对多数实数，计算机都无法精确存储。这造成误差。在用计算机解决实际问题时，要考虑上述误差的积累。







